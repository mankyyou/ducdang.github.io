<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini MU-like (Phaser 3)</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#1e2a38; display:flex; align-items:center; justify-content:center; }
    #game { outline: 2px solid #fff; border-radius:12px; }
  </style>
</head>
<body>
  <div id="game"></div>
  <script>
    const WIDTH = 800, HEIGHT = 500;

    const config = {
      type: Phaser.AUTO,
      width: WIDTH,
      height: HEIGHT,
      parent: 'game',
      backgroundColor: '#2c3e50',
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scene: { preload, create, update }
    };

    let player, enemies, cursors, spaceKey;
    let uiGfx, lastPlayerHitTime = 0;

    function preload() {
      // T·∫°o texture ƒë∆°n gi·∫£n b·∫±ng code (kh√¥ng c·∫ßn ·∫£nh)
      const g = this.add.graphics();

      // Player (cam)
      g.fillStyle(0xffa500, 1);
      g.fillRect(0, 0, 32, 32);
      g.lineStyle(2, 0xffffff, 1);
      g.strokeRect(0, 0, 32, 32);
      g.generateTexture('player', 32, 32);
      g.clear();

      // Enemy (xanh l√°)
      g.fillStyle(0x2ecc71, 1);
      g.fillRect(0, 0, 28, 28);
      g.lineStyle(2, 0x145a32, 1);
      g.strokeRect(0, 0, 28, 28);
      g.generateTexture('slime', 28, 28);
      g.clear();

      // Attack flash
      g.fillStyle(0xffffff, 1);
      g.fillCircle(8, 8, 8);
      g.generateTexture('hit', 16, 16);
      g.destroy();
    }

    function create() {
      // Player
      player = this.physics.add.sprite(WIDTH/2, HEIGHT/2, 'player');
      player.setCollideWorldBounds(true);
      player.speed = 200;
      player.maxHP = 100;
      player.hp = 100;
      player.attackRange = 40;
      player.attackDamage = 18;
      player.attackCooldown = 250;
      player.lastAttack = 0;

      // Enemies group
      enemies = this.physics.add.group();

      // Spawn v√†i con qu√°i
      for (let i = 0; i < 6; i++) {
        const x = Phaser.Math.Between(60, WIDTH-60);
        const y = Phaser.Math.Between(60, HEIGHT-60);
        const e = enemies.create(x, y, 'slime');
        e.setCollideWorldBounds(true);
        e.speed = Phaser.Math.Between(60, 90);
        e.maxHP = 35;
        e.hp = e.maxHP;
        e.lastBlinked = 0;
      }

      // Input
      cursors = this.input.keyboard.createCursorKeys();
      spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // Overlap ƒë·ªÉ qu√°i ch·∫°m g√¢y s√°t th∆∞∆°ng
      this.physics.add.overlap(player, enemies, (p, e) => {
        const now = this.time.now;
        if (now - lastPlayerHitTime > 500) {
          damagePlayer(10, this);
          lastPlayerHitTime = now;
          blink(e, this);
        }
      });

      // UI
      uiGfx = this.add.graphics();

      // H∆∞·ªõng d·∫´n
      const help = this.add.text(12, 10,
        'M≈©i t√™n: Di chuy·ªÉn   |   Space: ƒê√°nh   |   Ti√™u di·ªát t·∫•t c·∫£ qu√°i ƒë·ªÉ th·∫Øng',
        { fontFamily: 'sans-serif', fontSize: '16px', color: '#ecf0f1' }
      ).setScrollFactor(0).setDepth(10);
    }

    function update(time, delta) {
      handleMove.call(this);
      enemiesAI.call(this, delta);
      handleAttack.call(this, time);

      drawUI.call(this);

      // Th·∫Øng/thua
      if (player.hp <= 0) {
        gameOver.call(this, false);
        this.scene.pause();
      }
      if (enemies.countActive(true) === 0) {
        gameOver.call(this, true);
        this.scene.pause();
      }
    }

    function handleMove() {
      player.setVelocity(0, 0);
      if (cursors.left.isDown)  player.setVelocityX(-player.speed);
      if (cursors.right.isDown) player.setVelocityX(player.speed);
      if (cursors.up.isDown)    player.setVelocityY(-player.speed);
      if (cursors.down.isDown)  player.setVelocityY(player.speed);
    }

    function enemiesAI(delta) {
      enemies.children.iterate(e => {
        if (!e || !e.active) return;
        const angle = Phaser.Math.Angle.Between(e.x, e.y, player.x, player.y);
        const vx = Math.cos(angle) * e.speed;
        const vy = Math.sin(angle) * e.speed;
        e.setVelocity(vx, vy);
      });
    }

    function handleAttack(now) {
      if (!Phaser.Input.Keyboard.JustDown(spaceKey)) return;
      if (now - player.lastAttack < player.attackCooldown) return;
      player.lastAttack = now;

      // Hi·ªáu ·ª©ng ƒë√°nh
      const hit = this.add.image(player.x, player.y, 'hit').setAlpha(0.9);
      this.tweens.add({
        targets: hit, alpha: 0, duration: 150, onComplete: () => hit.destroy()
      });

      // G√¢y damage cho qu√°i trong ph·∫°m vi
      enemies.children.iterate(e => {
        if (!e || !e.active) return;
        const dist = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
        if (dist <= player.attackRange) {
          e.hp -= player.attackDamage;
          blink(e, this);
          if (e.hp <= 0) {
            e.disableBody(true, true);
          }
        }
      });
    }

    function blink(entity, scene) {
      // Nh√°y ƒë·ªÉ b√°o tr√∫ng ƒë√≤n
      scene.tweens.add({
        targets: entity, alpha: 0.3, yoyo: true, duration: 60, repeat: 2
      });
    }

    function damagePlayer(dmg, scene) {
      player.hp = Math.max(0, player.hp - dmg);
      scene.tweens.add({ targets: player, tint: 0xff5555, yoyo: true, duration: 80 });
    }

    function drawUI() {
      uiGfx.clear();
      // Thanh m√°u player
      const w = 220, h = 14, x = 12, y = HEIGHT - 26;
      const ratio = Phaser.Math.Clamp(player.hp / player.maxHP, 0, 1);
      uiGfx.fillStyle(0x000000, 0.5);
      uiGfx.fillRoundedRect(x-2, y-2, w+4, h+4, 6);
      uiGfx.fillStyle(0xe74c3c, 1);
      uiGfx.fillRoundedRect(x, y, w * ratio, h, 6);
      uiGfx.lineStyle(2, 0xecf0f1, 1);
      uiGfx.strokeRoundedRect(x, y, w, h, 6);

      // S·ªë qu√°i c√≤n l·∫°i
      const txt = `HP: ${player.hp}/${player.maxHP}   |   Qu√°i c√≤n: ${enemies.countActive(true)}`;
      this.game.canvas.getContext && this; // no-op ƒë·ªÉ gi·ªØ linter im l·∫∑ng
      if (!this.statusText) {
        this.statusText = this.add.text(WIDTH - 240, HEIGHT - 36, txt,
          { fontFamily: 'sans-serif', fontSize: '16px', color: '#ecf0f1' });
        this.statusText.setDepth(10);
      } else {
        this.statusText.setText(txt);
      }
    }

    function gameOver(win) {
      const msg = win ? 'üéâ TH·∫ÆNG: B·∫°n ƒë√£ ti√™u di·ªát h·∫øt qu√°i!' : 'üíÄ THUA: B·∫°n ƒë√£ g·ª•c ng√£!';
      const t = this.add.text(WIDTH/2, HEIGHT/2, msg, {
        fontFamily: 'sans-serif', fontSize: '28px', color: '#ffffff'
      }).setOrigin(0.5).setDepth(20);
      this.add.text(WIDTH/2, HEIGHT/2 + 40, 'F5 ƒë·ªÉ ch∆°i l·∫°i',
        { fontFamily: 'sans-serif', fontSize: '16px', color: '#bdc3c7' })
        .setOrigin(0.5).setDepth(20);
    }

    new Phaser.Game(config);
  </script>
</body>
</html>
